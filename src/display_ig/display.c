#include "rpi.h"
#include "display.h"
#include "i2c.h"

// This library is based on the ADAfruit SSD1306 library
// https://github.com/adafruit/Adafruit_SSD1306/tree/master
// https://github.com/adafruit/Adafruit-GFX-Library

static uint8_t buffer[1 + DISPLAY_BUFFER_SIZE];
static uint8_t *display_buffer = buffer + 1;

static display_graph_configuration_t graph_config = {
  // Initialize graph configuration with default values
  .margin_left = 10,
  .margin_right = 5,
  .margin_bottom = 10,
  .margin_top = 5,

  .x_axis_min = 0,
  .x_axis_max = 10,

  .y_axis_min = 0,
  .y_axis_max = 10,
};

#ifndef pgm_read_byte
#define pgm_read_byte(addr) (*(const unsigned char *)(addr))
#endif

#define SWAP(x, y)                                                             \
  do {                                                                         \
    typeof(x) SWAP = x;                                                        \
    x = y;                                                                     \
    y = SWAP;                                                                  \
  } while (0)

// Initialize the display. Requirement: I2C should have been initialized
// beforehand
void display_init(void) {
  // Display initialization flow [SSD1306 datasheet pg 64]
  // 0. Turn the display off to be safe [SSD1306 pg 28]
  display_send_command(0xAE);

  // 1. Set multiplex ratio
  display_send_command(0xA8);
  display_send_command(0x3F); // use offset 63 because display is 64 pixels tall

  // 2. Set display offset [SSD1306 pg 37]
  display_send_command(0xD3); // double byte command
  display_send_command(0x00); // map display start line to COM0 [SSD1306 pg 37]

  // 3. Set display start line [SSD1306 pg 36]
  display_send_command(0x40); // RAM row 0 is mapped to COM0

  // 4. Set segment re-map [SSD1306 pg 36]
  display_send_command(0xA0); // column addr 0 is mapped to SEG0

  // 5. Set COM output scan direction
  display_send_command(0xC8); // COM normal [SSD1306 pg 38]

  // 6. Set COM pins hardware configuration [SSD1306 pg 40]
  display_send_command(0xDA);
  display_send_command(0x12); // [SSD1206 pg 11] diagram says to use 0x12

  // 7. Set contrast control [SSD1306 pg 36]
  display_send_command(0x81); // double byte command
  // the chip has 256 contrast steps from 00h to FFH
  // recommended value seems to be 127 (middle of the range)
  display_send_command(0x7F);

  // 8. Display output according to GDDRAM contents [SSD1306 pg 37]
  display_send_command(0xA4);
  // display_send_command(0xA5);

  // 9. Set normal or inverse display [SSD1306 pg 37]
  display_send_command(0xA6); // normal
  // display_send_command(0xA7);  // inverse

  // 10. Set display clock divide ratio/oscillator frequency [SSD1306 pg 40]
  display_send_command(0xD5); // double byte command
  display_send_command(0x80); // default value ... formula on pg 22

  // 11. Enable charge pump regulator [SSD1306 pg 62]
  display_send_command(0x8D); // double byte command
  display_send_command(0x14); // enable charge pump

  // 12. Specify HORIZONTAL addressing mode [SSD1306 pg 35]
  // display_send_command(0x20);
  // display_send_command(0x02);   // page addressing mode [SSD1306 pg 34]
  display_send_command(0x20);
  display_send_command(0x00); // horizontal addressing mode
  display_send_command(0x21); // set column address
  display_send_command(0x00); // start at column 0
  display_send_command(0x7F); // end at column 127
  display_send_command(0x22); // set page address
  display_send_command(0x00); // start at page 0
  display_send_command(0x07); // end at page 7

  // 13. Display on [SSD1306 pg 62]
  display_send_command(0xAF);

  // 14. Clear the screen to black
  display_clear();
  display_show();
}

// Send display buffer to screen via I2C
// Must be called to actually update the display!
void display_show(void) {
  buffer[0] = 0x40; // control byte to indicate data
  i2c_write(DISPLAY_ADDRESS, buffer, sizeof(buffer));
}

// Helper function to send a byte over I2C
void display_send_command(uint8_t cmd) {
  uint8_t cmd_buf[2] = {0x00, cmd};
  i2c_write(DISPLAY_ADDRESS, cmd_buf, 2);
}

// Clears the screen to black; no change until display_show() is called
void display_clear(void) {
  buffer[0] = 0x40; // control byte to indicate data
  memset(display_buffer, 0, DISPLAY_BUFFER_SIZE);
}

// Fills the display completely with white
void display_fill_white(void) {
  buffer[0] = 0x40; // control byte to indicate data
  memset(display_buffer, 155, DISPLAY_BUFFER_SIZE);
}

// Draw a pixel at coordinates (x, y) with specified color
// Convention: top left corner of screen is pixel (0, 0)
void display_draw_pixel(uint16_t x, uint16_t y, color_t color) {
  x = DISPLAY_WIDTH - x - 1;
  switch (color) {
  case COLOR_WHITE:
    display_buffer[(y / 8) * DISPLAY_WIDTH + x] |= (1 << (y & 7));
    break;
  case COLOR_BLACK:
    display_buffer[(y / 8) * DISPLAY_WIDTH + x] &= ~(1 << (y & 7));
    break;
  case COLOR_INVERT:
    display_buffer[(y / 8) * DISPLAY_WIDTH + x] ^= (1 << (y & 7));
    break;
  }
}

// Draw a horizontal line from (x_start, y) to (x_end, y), inclusive of both
// endpoins Convention: top left corner of screen is pixel (0, 0)
void display_draw_horizontal_line(int16_t x_start, int16_t x_end, int16_t y,
                                  color_t color) {

  x_start = x_start < 0 ? 0 : x_start;
  x_end = x_end > DISPLAY_WIDTH - 1 ? DISPLAY_WIDTH - 1 : x_end;

  x_start = DISPLAY_WIDTH - x_start - 1;
  x_end = DISPLAY_WIDTH - x_end - 1;

  SWAP(x_start, x_end);

  if ((y >= 0) && (y < DISPLAY_HEIGHT)) {
    int16_t w = x_end - x_start;
    uint8_t *pBuf = &display_buffer[(y / 8) * DISPLAY_WIDTH + x_start];
    uint8_t mask = 1 << (y & 7);

    switch (color) {
    case COLOR_WHITE:
      while (w--) {
        *pBuf++ |= mask;
      };
      break;
    case COLOR_BLACK:
      mask = ~mask;
      while (w--) {
        *pBuf++ &= mask;
      };
      break;
    case COLOR_INVERT:
      while (w--) {
        *pBuf++ ^= mask;
      };
      break;
    }
  }
}

// Draw a vertical line from (y_start, x) to (y_end, x), inclusive of both
// endpoints Convention: top left corner of screen is pixel (0, 0)
void display_draw_vertical_line(int16_t y_start, int16_t y_end, int16_t x,
                                color_t color) {
  y_start = y_start < 0 ? 0 : y_start;
  y_end = y_end > DISPLAY_HEIGHT - 1 ? DISPLAY_HEIGHT - 1 : y_end;

  x = DISPLAY_WIDTH - x - 1;

  if ((x >= 0) && (x < DISPLAY_WIDTH)) { // if x-coordinate is in bounds
    int16_t line_height = y_end - y_start;
    if (line_height > 0) { // if height is positive
      // this display doesn't need ints for coordinates,
      // use local byte registers for faster juggling
      uint8_t y = y_start, h = line_height;
      uint8_t *pBuf = &display_buffer[(y / 8) * DISPLAY_WIDTH + x];

      // do the first partial byte, if necessary - this requires some masking
      uint8_t mod = (y & 7);
      if (mod) {
        // mask off the high n bits we want to set
        mod = 8 - mod;
        // note - lookup table results in a nearly 10% performance
        // improvement in fill* functions
        uint8_t mask = ~(0xFF >> mod);
        // static const uint8_t PROGMEM premask[8] = {0x00, 0x80, 0xC0, 0xE0,
        //                                            0xF0, 0xF8, 0xFC, 0xFE};
        // uint8_t mask = pgm_read_byte(&premask[mod]);

        // adjust the mask if we're not going to reach the end of this byte
        if (h < mod) {
          mask &= (0XFF >> (mod - h));
        }

        switch (color) {
        case COLOR_WHITE:
          *pBuf |= mask;
          break;
        case COLOR_BLACK:
          *pBuf &= ~mask;
          break;
        case COLOR_INVERT:
          *pBuf ^= mask;
          break;
        }
        pBuf += DISPLAY_WIDTH;
      }

      if (h >= mod) { // More to go?
        h -= mod;
        // Write solid bytes while we can - effectively 8 rows at a time
        if (h >= 8) {
          if (color == COLOR_INVERT) {
            // separate copy of the code so we don't impact performance of
            // black/white write version with an extra comparison per loop
            do {
              *pBuf ^= 0xFF;         // Invert byte
              pBuf += DISPLAY_WIDTH; // Advance pointer 8 rows
              h -= 8;                // Subtract 8 rows from height
            } while (h >= 8);
          } else {
            // store a local value to work with
            uint8_t val = (color != COLOR_BLACK) ? 255 : 0;
            do {
              *pBuf = val;           // Set byte
              pBuf += DISPLAY_WIDTH; // Advance pointer 8 rows
              h -= 8;                // Subtract 8 rows from height
            } while (h >= 8);
          }
        }

        if (h) { // Do the final partial byte, if necessary
          mod = h & 7;
          // this time we want to mask the low bits of the byte,
          // vs the high bits we did above
          uint8_t mask = (1 << mod) - 1;
          // note - lookup table results in a nearly 10% performance
          // improvement in fill* functions
          // static const uint8_t PROGMEM postmask[8] = {0x00, 0x01, 0x03, 0x07,
          //                                             0x0F, 0x1F, 0x3F,
          //                                             0x7F};
          // uint8_t mask = pgm_read_byte(&postmask[mod]);
          switch (color) {
          case COLOR_WHITE:
            *pBuf |= mask;
            break;
          case COLOR_BLACK:
            *pBuf &= ~mask;
            break;
          case COLOR_INVERT:
            *pBuf ^= mask;
            break;
          }
        }
      }
    } // endif height is positive
  } // endif x-coordinates is in bounds
}

// Standard ASCII 5x7 font
static const unsigned char font[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x5B, 0x4F, 0x5B, 0x3E, 0x3E, 0x6B,
    0x4F, 0x6B, 0x3E, 0x1C, 0x3E, 0x7C, 0x3E, 0x1C, 0x18, 0x3C, 0x7E, 0x3C,
    0x18, 0x1C, 0x57, 0x7D, 0x57, 0x1C, 0x1C, 0x5E, 0x7F, 0x5E, 0x1C, 0x00,
    0x18, 0x3C, 0x18, 0x00, 0xFF, 0xE7, 0xC3, 0xE7, 0xFF, 0x00, 0x18, 0x24,
    0x18, 0x00, 0xFF, 0xE7, 0xDB, 0xE7, 0xFF, 0x30, 0x48, 0x3A, 0x06, 0x0E,
    0x26, 0x29, 0x79, 0x29, 0x26, 0x40, 0x7F, 0x05, 0x05, 0x07, 0x40, 0x7F,
    0x05, 0x25, 0x3F, 0x5A, 0x3C, 0xE7, 0x3C, 0x5A, 0x7F, 0x3E, 0x1C, 0x1C,
    0x08, 0x08, 0x1C, 0x1C, 0x3E, 0x7F, 0x14, 0x22, 0x7F, 0x22, 0x14, 0x5F,
    0x5F, 0x00, 0x5F, 0x5F, 0x06, 0x09, 0x7F, 0x01, 0x7F, 0x00, 0x66, 0x89,
    0x95, 0x6A, 0x60, 0x60, 0x60, 0x60, 0x60, 0x94, 0xA2, 0xFF, 0xA2, 0x94,
    0x08, 0x04, 0x7E, 0x04, 0x08, 0x10, 0x20, 0x7E, 0x20, 0x10, 0x08, 0x08,
    0x2A, 0x1C, 0x08, 0x08, 0x1C, 0x2A, 0x08, 0x08, 0x1E, 0x10, 0x10, 0x10,
    0x10, 0x0C, 0x1E, 0x0C, 0x1E, 0x0C, 0x30, 0x38, 0x3E, 0x38, 0x30, 0x06,
    0x0E, 0x3E, 0x0E, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F,
    0x00, 0x00, 0x00, 0x07, 0x00, 0x07, 0x00, 0x14, 0x7F, 0x14, 0x7F, 0x14,
    0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x23, 0x13, 0x08, 0x64, 0x62, 0x36, 0x49,
    0x56, 0x20, 0x50, 0x00, 0x08, 0x07, 0x03, 0x00, 0x00, 0x1C, 0x22, 0x41,
    0x00, 0x00, 0x41, 0x22, 0x1C, 0x00, 0x2A, 0x1C, 0x7F, 0x1C, 0x2A, 0x08,
    0x08, 0x3E, 0x08, 0x08, 0x00, 0x80, 0x70, 0x30, 0x00, 0x08, 0x08, 0x08,
    0x08, 0x08, 0x00, 0x00, 0x60, 0x60, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02,
    0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x42, 0x7F, 0x40, 0x00, 0x72, 0x49,
    0x49, 0x49, 0x46, 0x21, 0x41, 0x49, 0x4D, 0x33, 0x18, 0x14, 0x12, 0x7F,
    0x10, 0x27, 0x45, 0x45, 0x45, 0x39, 0x3C, 0x4A, 0x49, 0x49, 0x31, 0x41,
    0x21, 0x11, 0x09, 0x07, 0x36, 0x49, 0x49, 0x49, 0x36, 0x46, 0x49, 0x49,
    0x29, 0x1E, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x40, 0x34, 0x00, 0x00,
    0x00, 0x08, 0x14, 0x22, 0x41, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x41,
    0x22, 0x14, 0x08, 0x02, 0x01, 0x59, 0x09, 0x06, 0x3E, 0x41, 0x5D, 0x59,
    0x4E, 0x7C, 0x12, 0x11, 0x12, 0x7C, 0x7F, 0x49, 0x49, 0x49, 0x36, 0x3E,
    0x41, 0x41, 0x41, 0x22, 0x7F, 0x41, 0x41, 0x41, 0x3E, 0x7F, 0x49, 0x49,
    0x49, 0x41, 0x7F, 0x09, 0x09, 0x09, 0x01, 0x3E, 0x41, 0x41, 0x51, 0x73,
    0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x41, 0x7F, 0x41, 0x00, 0x20, 0x40,
    0x41, 0x3F, 0x01, 0x7F, 0x08, 0x14, 0x22, 0x41, 0x7F, 0x40, 0x40, 0x40,
    0x40, 0x7F, 0x02, 0x1C, 0x02, 0x7F, 0x7F, 0x04, 0x08, 0x10, 0x7F, 0x3E,
    0x41, 0x41, 0x41, 0x3E, 0x7F, 0x09, 0x09, 0x09, 0x06, 0x3E, 0x41, 0x51,
    0x21, 0x5E, 0x7F, 0x09, 0x19, 0x29, 0x46, 0x26, 0x49, 0x49, 0x49, 0x32,
    0x03, 0x01, 0x7F, 0x01, 0x03, 0x3F, 0x40, 0x40, 0x40, 0x3F, 0x1F, 0x20,
    0x40, 0x20, 0x1F, 0x3F, 0x40, 0x38, 0x40, 0x3F, 0x63, 0x14, 0x08, 0x14,
    0x63, 0x03, 0x04, 0x78, 0x04, 0x03, 0x61, 0x59, 0x49, 0x4D, 0x43, 0x00,
    0x7F, 0x41, 0x41, 0x41, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x41, 0x41,
    0x41, 0x7F, 0x04, 0x02, 0x01, 0x02, 0x04, 0x40, 0x40, 0x40, 0x40, 0x40,
    0x00, 0x03, 0x07, 0x08, 0x00, 0x20, 0x54, 0x54, 0x78, 0x40, 0x7F, 0x28,
    0x44, 0x44, 0x38, 0x38, 0x44, 0x44, 0x44, 0x28, 0x38, 0x44, 0x44, 0x28,
    0x7F, 0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x08, 0x7E, 0x09, 0x02, 0x18,
    0xA4, 0xA4, 0x9C, 0x78, 0x7F, 0x08, 0x04, 0x04, 0x78, 0x00, 0x44, 0x7D,
    0x40, 0x00, 0x20, 0x40, 0x40, 0x3D, 0x00, 0x7F, 0x10, 0x28, 0x44, 0x00,
    0x00, 0x41, 0x7F, 0x40, 0x00, 0x7C, 0x04, 0x78, 0x04, 0x78, 0x7C, 0x08,
    0x04, 0x04, 0x78, 0x38, 0x44, 0x44, 0x44, 0x38, 0xFC, 0x18, 0x24, 0x24,
    0x18, 0x18, 0x24, 0x24, 0x18, 0xFC, 0x7C, 0x08, 0x04, 0x04, 0x08, 0x48,
    0x54, 0x54, 0x54, 0x24, 0x04, 0x04, 0x3F, 0x44, 0x24, 0x3C, 0x40, 0x40,
    0x20, 0x7C, 0x1C, 0x20, 0x40, 0x20, 0x1C, 0x3C, 0x40, 0x30, 0x40, 0x3C,
    0x44, 0x28, 0x10, 0x28, 0x44, 0x4C, 0x90, 0x90, 0x90, 0x7C, 0x44, 0x64,
    0x54, 0x4C, 0x44, 0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, 0x77, 0x00,
    0x00, 0x00, 0x41, 0x36, 0x08, 0x00, 0x02, 0x01, 0x02, 0x04, 0x02, 0x3C,
    0x26, 0x23, 0x26, 0x3C, 0x1E, 0xA1, 0xA1, 0x61, 0x12, 0x3A, 0x40, 0x40,
    0x20, 0x7A, 0x38, 0x54, 0x54, 0x55, 0x59, 0x21, 0x55, 0x55, 0x79, 0x41,
    0x22, 0x54, 0x54, 0x78, 0x42, // a-umlaut
    0x21, 0x55, 0x54, 0x78, 0x40, 0x20, 0x54, 0x55, 0x79, 0x40, 0x0C, 0x1E,
    0x52, 0x72, 0x12, 0x39, 0x55, 0x55, 0x55, 0x59, 0x39, 0x54, 0x54, 0x54,
    0x59, 0x39, 0x55, 0x54, 0x54, 0x58, 0x00, 0x00, 0x45, 0x7C, 0x41, 0x00,
    0x02, 0x45, 0x7D, 0x42, 0x00, 0x01, 0x45, 0x7C, 0x40, 0x7D, 0x12, 0x11,
    0x12, 0x7D, // A-umlaut
    0xF0, 0x28, 0x25, 0x28, 0xF0, 0x7C, 0x54, 0x55, 0x45, 0x00, 0x20, 0x54,
    0x54, 0x7C, 0x54, 0x7C, 0x0A, 0x09, 0x7F, 0x49, 0x32, 0x49, 0x49, 0x49,
    0x32, 0x3A, 0x44, 0x44, 0x44, 0x3A, // o-umlaut
    0x32, 0x4A, 0x48, 0x48, 0x30, 0x3A, 0x41, 0x41, 0x21, 0x7A, 0x3A, 0x42,
    0x40, 0x20, 0x78, 0x00, 0x9D, 0xA0, 0xA0, 0x7D, 0x3D, 0x42, 0x42, 0x42,
    0x3D, // O-umlaut
    0x3D, 0x40, 0x40, 0x40, 0x3D, 0x3C, 0x24, 0xFF, 0x24, 0x24, 0x48, 0x7E,
    0x49, 0x43, 0x66, 0x2B, 0x2F, 0xFC, 0x2F, 0x2B, 0xFF, 0x09, 0x29, 0xF6,
    0x20, 0xC0, 0x88, 0x7E, 0x09, 0x03, 0x20, 0x54, 0x54, 0x79, 0x41, 0x00,
    0x00, 0x44, 0x7D, 0x41, 0x30, 0x48, 0x48, 0x4A, 0x32, 0x38, 0x40, 0x40,
    0x22, 0x7A, 0x00, 0x7A, 0x0A, 0x0A, 0x72, 0x7D, 0x0D, 0x19, 0x31, 0x7D,
    0x26, 0x29, 0x29, 0x2F, 0x28, 0x26, 0x29, 0x29, 0x29, 0x26, 0x30, 0x48,
    0x4D, 0x40, 0x20, 0x38, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
    0x38, 0x2F, 0x10, 0xC8, 0xAC, 0xBA, 0x2F, 0x10, 0x28, 0x34, 0xFA, 0x00,
    0x00, 0x7B, 0x00, 0x00, 0x08, 0x14, 0x2A, 0x14, 0x22, 0x22, 0x14, 0x2A,
    0x14, 0x08, 0x55, 0x00, 0x55, 0x00, 0x55, // #176 (25% block) missing in old
                                              // code
    0xAA, 0x55, 0xAA, 0x55, 0xAA,             // 50% block
    0xFF, 0x55, 0xFF, 0x55, 0xFF,             // 75% block
    0x00, 0x00, 0x00, 0xFF, 0x00, 0x10, 0x10, 0x10, 0xFF, 0x00, 0x14, 0x14,
    0x14, 0xFF, 0x00, 0x10, 0x10, 0xFF, 0x00, 0xFF, 0x10, 0x10, 0xF0, 0x10,
    0xF0, 0x14, 0x14, 0x14, 0xFC, 0x00, 0x14, 0x14, 0xF7, 0x00, 0xFF, 0x00,
    0x00, 0xFF, 0x00, 0xFF, 0x14, 0x14, 0xF4, 0x04, 0xFC, 0x14, 0x14, 0x17,
    0x10, 0x1F, 0x10, 0x10, 0x1F, 0x10, 0x1F, 0x14, 0x14, 0x14, 0x1F, 0x00,
    0x10, 0x10, 0x10, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x10, 0x10, 0x10,
    0x10, 0x1F, 0x10, 0x10, 0x10, 0x10, 0xF0, 0x10, 0x00, 0x00, 0x00, 0xFF,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xFF, 0x10, 0x00,
    0x00, 0x00, 0xFF, 0x14, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x1F,
    0x10, 0x17, 0x00, 0x00, 0xFC, 0x04, 0xF4, 0x14, 0x14, 0x17, 0x10, 0x17,
    0x14, 0x14, 0xF4, 0x04, 0xF4, 0x00, 0x00, 0xFF, 0x00, 0xF7, 0x14, 0x14,
    0x14, 0x14, 0x14, 0x14, 0x14, 0xF7, 0x00, 0xF7, 0x14, 0x14, 0x14, 0x17,
    0x14, 0x10, 0x10, 0x1F, 0x10, 0x1F, 0x14, 0x14, 0x14, 0xF4, 0x14, 0x10,
    0x10, 0xF0, 0x10, 0xF0, 0x00, 0x00, 0x1F, 0x10, 0x1F, 0x00, 0x00, 0x00,
    0x1F, 0x14, 0x00, 0x00, 0x00, 0xFC, 0x14, 0x00, 0x00, 0xF0, 0x10, 0xF0,
    0x10, 0x10, 0xFF, 0x10, 0xFF, 0x14, 0x14, 0x14, 0xFF, 0x14, 0x10, 0x10,
    0x10, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x10, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x38, 0x44, 0x44,
    0x38, 0x44, 0xFC, 0x4A, 0x4A, 0x4A, 0x34, // sharp-s or beta
    0x7E, 0x02, 0x02, 0x06, 0x06, 0x02, 0x7E, 0x02, 0x7E, 0x02, 0x63, 0x55,
    0x49, 0x41, 0x63, 0x38, 0x44, 0x44, 0x3C, 0x04, 0x40, 0x7E, 0x20, 0x1E,
    0x20, 0x06, 0x02, 0x7E, 0x02, 0x02, 0x99, 0xA5, 0xE7, 0xA5, 0x99, 0x1C,
    0x2A, 0x49, 0x2A, 0x1C, 0x4C, 0x72, 0x01, 0x72, 0x4C, 0x30, 0x4A, 0x4D,
    0x4D, 0x30, 0x30, 0x48, 0x78, 0x48, 0x30, 0xBC, 0x62, 0x5A, 0x46, 0x3D,
    0x3E, 0x49, 0x49, 0x49, 0x00, 0x7E, 0x01, 0x01, 0x01, 0x7E, 0x2A, 0x2A,
    0x2A, 0x2A, 0x2A, 0x44, 0x44, 0x5F, 0x44, 0x44, 0x40, 0x51, 0x4A, 0x44,
    0x40, 0x40, 0x44, 0x4A, 0x51, 0x40, 0x00, 0x00, 0xFF, 0x01, 0x03, 0xE0,
    0x80, 0xFF, 0x00, 0x00, 0x08, 0x08, 0x6B, 0x6B, 0x08, 0x36, 0x12, 0x36,
    0x24, 0x36, 0x06, 0x0F, 0x09, 0x0F, 0x06, 0x00, 0x00, 0x18, 0x18, 0x00,
    0x00, 0x00, 0x10, 0x10, 0x00, 0x30, 0x40, 0xFF, 0x01, 0x01, 0x00, 0x1F,
    0x01, 0x01, 0x1E, 0x00, 0x19, 0x1D, 0x17, 0x12, 0x00, 0x3C, 0x3C, 0x3C,
    0x3C, 0x00, 0x00, 0x00, 0x00, 0x00 // #255 NBSP
};

// Draw an ASCII character at (x, y) with specified color
// Convention: top left corner of screen is pixel (0, 0)
void display_draw_character(int16_t x, int16_t y, unsigned char c,
                            color_t color) {
  if ((x >= DISPLAY_WIDTH) ||  // Clip right
      (y >= DISPLAY_HEIGHT) || // Clip bottom
      ((x + 6 - 1) < 0) ||     // Clip left
      ((y + 8 - 1) < 0))       // Clip top
    return;

  for (int8_t i = 0; i < 5; i++) { // Char bitmap = 5 columns
    uint8_t line = pgm_read_byte(&font[c * 5 + i]);
    for (int8_t j = 0; j < 8; j++, line >>= 1) {
      if (line & 1) {
        display_draw_pixel(x + i, y + j, color);
      }
    }
  }
}

void display_configure_graph_axes(int16_t x_min, int16_t x_max, int16_t y_min, int16_t y_max) {
  // Graph config
  graph_config.x_axis_span = graph_config.x_axis_max - graph_config.x_axis_min;
  graph_config.y_axis_span = graph_config.y_axis_max - graph_config.y_axis_min;

  graph_config.y_horizontal = graph_config.y_axis_max / graph_config.y_axis_span * (DISPLAY_HEIGHT - graph_config.margin_top - graph_config.margin_bottom) + graph_config.margin_top;
  graph_config.x_vertical = -graph_config.x_axis_min / graph_config.x_axis_span * (DISPLAY_WIDTH - graph_config.margin_left - graph_config.margin_right) + graph_config.margin_left;

}

void display_draw_graph_axes(void) {
  // Draw horizontal line for the graph x-axis
  display_draw_horizontal_line(graph_config.margin_left, DISPLAY_WIDTH - graph_config.margin_right, graph_config.y_horizontal, COLOR_WHITE);

  // Draw vertical line for the graph y-axis
  display_draw_vertical_line(graph_config.margin_top, DISPLAY_HEIGHT - graph_config.margin_bottom, graph_config.x_vertical, COLOR_WHITE);

  // Draw label for x-axis maximum
  char x_buffer[6];
  snprintk(x_buffer, sizeof(x_buffer), "%d", graph_config.x_axis_max);

  for (size_t i = 1; i <= strlen(x_buffer); i++) {
    display_draw_character(DISPLAY_WIDTH - graph_config.margin_right - 5 * i,
      graph_config.y_horizontal + 1,
      x_buffer[strlen(x_buffer) - i],
      COLOR_WHITE);
  }

  // Draw label for y-axis maximum
  char y_buffer[6];
  snprintk(y_buffer, sizeof(y_buffer), "%d", graph_config.y_axis_max);

  for (size_t i = 1; i <= strlen(y_buffer); i++) {
    display_draw_character(graph_config.x_vertical - 5 * i,
      graph_config.margin_top,
      y_buffer[strlen(y_buffer) - i],
      COLOR_WHITE);
  }
}

void display_draw_graph_data(void) {
  float x_values[10] = {0, 1.2, 2.4, 3.6, 4.8, 6.0, 7.2, 8.4, 9.6, 10.8};
  float y_values[10] = {4.997, 1.617, 1.617, 1.617, 0.016, 0.016, 1.085, 1.085, 4.223, 4.223};

  // float graph_x_axis_range = graph_x_axis_max - graph_x_axis_min;
  // int16_t x_vertical = -graph_x_axis_min / graph_x_axis_range * (DISPLAY_WIDTH - graph_margin_left - graph_margin_right) + graph_margin_left;
  // float graph_y_axis_range = graph_y_axis_max - graph_y_axis_min;
  // int16_t y_horizontal = graph_y_axis_max / graph_y_axis_range * (DISPLAY_HEIGHT - graph_margin_top - graph_margin_bottom) + graph_margin_top;

  for (size_t i = 0; i < 10; i++) {
    // Graph a single point
    float x = x_values[i];
    float y = y_values[i];

    x = (x - graph_config.x_axis_min) / graph_config.x_axis_span * (DISPLAY_WIDTH - graph_config.margin_left - graph_config.margin_right) + graph_config.margin_left;
    y = (graph_config.y_axis_max - y) / graph_config.y_axis_span * (DISPLAY_HEIGHT - graph_config.margin_top - graph_config.margin_bottom) + graph_config.margin_top;

    display_draw_pixel(x, y, COLOR_WHITE);
  }

}